{"version":3,"sources":["../node_modules/@ui5/webcomponents/dist/generated/templates/RangeSliderTemplate.lit.js","../node_modules/@ui5/webcomponents/dist/RangeSlider.js"],"names":["block1","context","html","showTickmarks","block2","undefined","styleMap","styles","tickmarks","labelInterval","block3","classMap","classes","labelContainer","repeat","_labels","item","index","_id","block4","label","ifDefined","block5","tooltip","tooltipStartValue","block6","tooltipEndValue","main","tags","suffix","setTags","setSuffix","_onmousedown","_ontouchstart","_onmouseover","_onmouseout","effectiveDir","step","progress","startHandle","showTooltip","endHandle","block0","metadata","tag","languageAware","managedSlots","properties","startValue","type","Float","defaultValue","endValue","RangeSlider","_stateStorage","i18nBundle","getI18nBundle","RangeSliderTemplate","this","isCurrentStateOutdated","notResized","syncUIAndState","_updateHandlesAndRange","event","disabled","_effectiveStep","newValue","handleDownBase","_saveInteractionStartData","_inCurrentRange","_handeIsPressed","updateValue","_valueAffected","storePropertyState","progressBarDom","shadowRoot","querySelector","getBoundingClientRect","_prevStartValue","_prevEndValue","_initialPageXPosition","constructor","getPageXValueFromEvent","_pressTargetAndAffectedValue","_initialStartHandlePageX","directionStart","left","right","preventDefault","_updateValueOnRangeDrag","_updateValueOnHandleDrag","getValueFromInteraction","_effectiveMin","_effectiveMax","currentPageXPos","newValues","_calculateRangeOffset","fireEvent","_swapValues","handleUpBase","clientX","value","handleStartDomRect","handleEndDomRect","inHandleStartDom","inHandleEndDom","initialStartHandlePageXPos","min","max","selectedRange","_calculateStartValueByOffset","clipValue","startValuePageX","dom","computedValueFromPageX","getSteppedValue","prevStartValue","getStoredPropertyState","prevEndValue","_selectedRange","_firstHandlePositionFromStart","_secondHandlePositionFromStart","oldEndValue","oldStartValue","stepPrecision","_getDecimalPrecisionOfNumber","toFixed","_tickmarks","_labelWidth","_tooltipVisibility","fetchI18nBundle","SliderBase","define"],"mappings":"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","file":"static/js/77.39619271.chunk.js","sourcesContent":["\n/* eslint no-unused-vars: 0 */\nimport ifDefined from '@ui5/webcomponents-base/dist/renderer/ifDefined.js';\nimport { html, svg, repeat, classMap, styleMap, unsafeHTML, setTags, setSuffix } from '@ui5/webcomponents-base/dist/renderer/LitRenderer.js';\nconst block0 = (context) => { return html`<div class=\"ui5-slider-root\" @mousedown=\"${context._onmousedown}\" @touchstart=\"${context._ontouchstart}\" @mouseover=\"${context._onmouseover}\" @mouseout=\"${context._onmouseout}\" dir=\"${ifDefined(context.effectiveDir)}\"><div class=\"ui5-slider-inner\">${ context.step ? block1(context) : undefined }<div class=\"ui5-slider-progress-container\"><div class=\"ui5-slider-progress\" style=\"${styleMap(context.styles.progress)}\"></div></div><div class=\"ui5-slider-handle ui5-slider-handle--start\" style=\"${styleMap(context.styles.startHandle)}\">${ context.showTooltip ? block5(context) : undefined }</div><div class=\"ui5-slider-handle ui5-slider-handle--end\" style=\"${styleMap(context.styles.endHandle)}\">${ context.showTooltip ? block6(context) : undefined }</div></div></div>`; };\nconst block1 = (context) => { return html`${ context.showTickmarks ? block2(context) : undefined }`; };\nconst block2 = (context) => { return html`<div class=\"ui5-slider-tickmarks\" style=\"${styleMap(context.styles.tickmarks)}\"></div>${ context.labelInterval ? block3(context) : undefined }`; };\nconst block3 = (context) => { return html`<ul class=\"ui5-slider-labels ${classMap(context.classes.labelContainer)}\" style=\"${styleMap(context.styles.labelContainer)}\">${ repeat(context._labels, (item, index) => item._id || index, (item, index) => block4(item, index, context)) }</ul>`; };\nconst block4 = (item, index, context) => { return html`<li style=\"${styleMap(context.styles.label)}\">${ifDefined(item)}</li>`; };\nconst block5 = (context) => { return html`<div class=\"ui5-slider-tooltip ui5-slider-tooltip--start\" style=\"${styleMap(context.styles.tooltip)}\"><span class=\"ui5-slider-tooltip-value\">${ifDefined(context.tooltipStartValue)}</span></div>`; };\nconst block6 = (context) => { return html`<div class=\"ui5-slider-tooltip ui5-slider-tooltip--end\" style=\"${styleMap(context.styles.tooltip)}\"><span class=\"ui5-slider-tooltip-value\">${ifDefined(context.tooltipEndValue)}</span></div>`; };\n\n\nconst main = (context, tags, suffix) => {\n\tsetTags(tags);\n\tsetSuffix(suffix);\n\treturn block0(context);\n};\n \nexport default main;","import Float from \"@ui5/webcomponents-base/dist/types/Float.js\";\nimport { fetchI18nBundle, getI18nBundle } from \"@ui5/webcomponents-base/dist/i18nBundle.js\";\nimport SliderBase from \"./SliderBase.js\";\n\n// Template\nimport RangeSliderTemplate from \"./generated/templates/RangeSliderTemplate.lit.js\";\n\n/**\n * @public\n */\nconst metadata = {\n\ttag: \"ui5-range-slider\",\n\tlanguageAware: true,\n\tmanagedSlots: true,\n\tproperties: /** @lends sap.ui.webcomponents.main.RangeSlider.prototype */  {\n\t\t/**\n\t\t * Defines start point of a selection - position of a first handle on the slider.\n\t\t * <br><br>\n\t\t *\n\t\t * @type {Float}\n\t\t * @defaultvalue 0\n\t\t * @public\n\t\t */\n\t\tstartValue: {\n\t\t\ttype: Float,\n\t\t\tdefaultValue: 0,\n\t\t},\n\t\t/**\n\t\t * Defines end point of a selection - position of a second handle on the slider.\n\t\t * <br><br>\n\t\t *\n\t\t * @type {Float}\n\t\t * @defaultvalue 100\n\t\t * @public\n\t\t */\n\t\tendValue: {\n\t\t\ttype: Float,\n\t\t\tdefaultValue: 100,\n\t\t},\n\t},\n};\n\n/**\n * @class\n *\n * Represents a numerical interval and two handles (grips) to select a sub-range within it.\n *\n * <h3 class=\"comment-api-title\">Overview</h3>\n * The purpose of the component to enable visual selection of sub-ranges within a given interval.\n *\n * <h3>Structure</h3>\n * The most important properties of the Range Slider are:\n * <ul>\n * <li>min - The minimum value of the slider range</li>\n * <li>max - The maximum value of the slider range</li>\n * <li>value - The current value of the slider</li>\n * <li>step - Determines the increments in which the slider will move</li>\n * <li>showTooltip - Determines if a tooltip should be displayed above the handle</li>\n * <li>showTickmarks - Displays a visual divider between the step values</li>\n * <li>labelInterval - Labels some or all of the tickmarks with their values.</li>\n * </ul>\n * <h4>Notes:<h4>\n * <ul>\n * <li>The right and left handle can be moved individually and their positions could therefore switch.</li>\n * <li>The entire range can be moved along the interval.</li>\n * </ul>\n * <h3>Usage</h3>\n * The most common usecase is to select and move sub-ranges on a continuous numerical scale.\n *\n * <h3>Responsive Behavior</h3>\n * You can move the currently selected range by clicking on it and dragging it along the interval.\n *\n * <h3>ES6 Module Import</h3>\n *\n * <code>import \"@ui5/webcomponents/dist/RangeSlider\";</code>\n *\n *\n * @constructor\n * @author SAP SE\n * @alias sap.ui.webcomponents.main.RangeSlider\n * @extends SliderBase\n * @tagname ui5-range-slider\n * @since 1.0.0-rc.11\n * @public\n */\nclass RangeSlider extends SliderBase {\n\tstatic get metadata() {\n\t\treturn metadata;\n\t}\n\n\tstatic get template() {\n\t\treturn RangeSliderTemplate;\n\t}\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._stateStorage.startValue = null;\n\t\tthis._stateStorage.endValue = null;\n\t\tthis.i18nBundle = getI18nBundle(\"@ui5/webcomponents\");\n\t}\n\n\tget tooltipStartValue() {\n\t\tconst stepPrecision = this.constructor._getDecimalPrecisionOfNumber(this._effectiveStep);\n\t\treturn this.startValue.toFixed(stepPrecision);\n\t}\n\n\tget tooltipEndValue() {\n\t\tconst stepPrecision = this.constructor._getDecimalPrecisionOfNumber(this._effectiveStep);\n\t\treturn this.endValue.toFixed(stepPrecision);\n\t}\n\n\t/**\n\t * Check if the previously saved state is outdated. That would mean\n\t * either it is the initial rendering or that a property has been changed\n\t * programatically - because the previous state is always updated in\n\t * the interaction handlers.\n\t *\n\t * Normalize current properties, update the previously stored state.\n\t * Update the visual UI representation of the Slider.\n\t *\n\t */\n\tonBeforeRendering() {\n\t\tif (!this.isCurrentStateOutdated()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.notResized = true;\n\t\tthis.syncUIAndState(\"startValue\", \"endValue\");\n\t\tthis._updateHandlesAndRange(null);\n\t}\n\n\t/**\n\t * Called when the user starts interacting with the slider\n\t *\n\t * @private\n\t */\n\t_onmousedown(event) {\n\t\t// If step is 0 no interaction is available because there is no constant\n\t\t// (equal for all user environments) quantitative representation of the value\n\t\tif (this.disabled || this._effectiveStep === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Calculate the new value from the press position of the event\n\t\tconst newValue = this.handleDownBase(event);\n\n\t\t// Determine the rest of the needed details from the start of the interaction.\n\t\tthis._saveInteractionStartData(event, newValue);\n\n\t\t// Do not yet update the RangeSlider if press is in range or over a handle.\n\t\tif (this._inCurrentRange || this._handeIsPressed) {\n\t\t\tthis._handeIsPressed = false;\n\t\t\treturn;\n\t\t}\n\n\t\t// Update Slider UI and internal state\n\t\tthis._updateHandlesAndRange(newValue);\n\t\tthis.updateValue(this._valueAffected, newValue);\n\t\tthis.storePropertyState(this._valueAffected);\n\t}\n\n\n\t/**\n\t * Determines and saves needed values from the start of the interaction:\n\t *\n\t * Is the value calculated is within the currently selected range;\n\t * Initial pageX position of the start handle affected by the interaction;\n\t * Initial pageX value of the pressed postion;\n\t * Affected value property by the action;\n\t *\n\t * @private\n\t */\n\t_saveInteractionStartData(event, newValue) {\n\t\tconst progressBarDom = this.shadowRoot.querySelector(\".ui5-slider-progress\").getBoundingClientRect();\n\n\t\t// Save the state of the value properties on the start of the interaction\n\t\tthis._prevStartValue = this.startValue;\n\t\tthis._prevEndValue = this.endValue;\n\n\t\t// Check if the new value is in the current select range of values\n\t\tthis._inCurrentRange = newValue > this._prevStartValue && newValue < this._prevEndValue;\n\t\t// Save the initial press point coordinates (position)\n\t\tthis._initialPageXPosition = this.constructor.getPageXValueFromEvent(event);\n\t\t// Which element of the Range Slider is pressed and which value property to be modified on further interaction\n\t\tthis._pressTargetAndAffectedValue(this._initialPageXPosition, newValue);\n\n\t\t// Use the progress bar to save the initial coordinates of the start-handle when the interaction begins.\n\t\t// We will use it as a reference to calculate a moving offset if the whole range selection is dragged.\n\t\tthis._initialStartHandlePageX = this.directionStart === \"left\" ? progressBarDom.left : progressBarDom.right;\n\t}\n\n\n\t/**\n\t * Called when the user moves the slider\n\t *\n\t * @private\n\t */\n\t_handleMove(event) {\n\t\tevent.preventDefault();\n\n\t\t// If 'step' is 0 no interaction is available as there is no constant quantitative representation of the value\n\t\tif (this.disabled || this._effectiveStep === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Update UI and state when dragging a single Range Slider handle\n\t\tif (!this._inCurrentRange) {\n\t\t\tthis._updateValueOnHandleDrag(event);\n\t\t\treturn;\n\t\t}\n\n\t\t// Updates UI and state when dragging of the whole selected range\n\t\tthis._updateValueOnRangeDrag(event);\n\t}\n\n\t/**\n\t * Updates UI and state when dragging a single Range Slider handle\n\t *\n\t * @private\n\t */\n\t_updateValueOnHandleDrag(event) {\n\t\tconst newValue = this.constructor.getValueFromInteraction(event, this._effectiveStep, this._effectiveMin, this._effectiveMax, this.getBoundingClientRect(), this.directionStart);\n\n\t\tthis._updateHandlesAndRange(newValue);\n\t\tthis.updateValue(this._valueAffected, newValue);\n\t\tthis.storePropertyState(this._valueAffected);\n\t}\n\n\t/**\n\t * Updates UI and state when dragging of the whole selected range\n\t *\n\t * @private\n\t */\n\t_updateValueOnRangeDrag(event) {\n\t\t// Calculate the new 'start' and 'end' values from the offset between the original press point and the current position of the mouse\n\t\tconst currentPageXPos = this.constructor.getPageXValueFromEvent(event);\n\t\tconst newValues = this._calculateRangeOffset(currentPageXPos, this._initialStartHandlePageX);\n\n\t\t// No matter the which value is set as the one to be modified (this._valueAffected) we want to modify both of them\n\t\tthis._valueAffected = null;\n\n\t\t// Update the UI and the state acccording to the calculated new values\n\t\tthis.updateValue(\"startValue\", newValues[0]);\n\t\tthis.updateValue(\"endValue\", newValues[1]);\n\t\tthis._updateHandlesAndRange(null);\n\t\tthis.storePropertyState(\"startValue\", \"endValue\");\n\t}\n\n\t_handleUp() {\n\t\tif (this.startValue !== this._prevStartValue || this.endValue !== this._prevEndValue) {\n\t\t\tthis.fireEvent(\"change\");\n\t\t}\n\n\t\tthis._swapValues();\n\t\tthis.handleUpBase();\n\n\t\tthis._valueAffected = null;\n\t\tthis._prevStartValue = null;\n\t\tthis._prevEndValue = null;\n\t}\n\n\t/**\n\t * Determines where the press occured and which values of the Range Slider\n\t * handles should be updated on further interaction.\n\t *\n\t * If the press is not in the selected range or over one of the Range Slider handles\n\t * determines which one from the value/endValue properties has to be updated\n\t * after the user action (based on closest handle).\n\t *\n\t * Set flags if the press is over a handle or in the selected range,\n\t * in such cases no values are changed on interaction start, but could be\n\t * updated later when dragging.\n\t *\n\t * @private\n\t */\n\t_pressTargetAndAffectedValue(clientX, value) {\n\t\tconst startHandle = this.shadowRoot.querySelector(\".ui5-slider-handle--start\");\n\t\tconst endHandle = this.shadowRoot.querySelector(\".ui5-slider-handle--end\");\n\n\t\t// Check if the press point is in the bounds of any of the Range Slider handles\n\t\tconst handleStartDomRect = startHandle.getBoundingClientRect();\n\t\tconst handleEndDomRect = endHandle.getBoundingClientRect();\n\t\tconst inHandleStartDom = clientX >= handleStartDomRect.left && clientX <= handleStartDomRect.right;\n\t\tconst inHandleEndDom = clientX >= handleEndDomRect.left && clientX <= handleEndDomRect.right;\n\n\t\t// Remove the flag for value in current range if the press action is over one of the handles\n\t\tif (inHandleEndDom || inHandleStartDom) {\n\t\t\tthis._inCurrentRange = false;\n\t\t\tthis._handeIsPressed = true;\n\t\t}\n\n\t\t// Return that handle that is closer to the press point\n\t\tif (inHandleEndDom || value > this.endValue) {\n\t\t\tthis._valueAffected = \"endValue\";\n\t\t}\n\n\t\t// If one of the handle is pressed return that one\n\t\tif (inHandleStartDom || value < this.startValue) {\n\t\t\tthis._valueAffected = \"startValue\";\n\t\t}\n\t}\n\n\t/**\n\t * Calculates startValue/endValue properties when the whole range is moved.\n\t *\n\t * Uses the change of the position of the start handle and adds the initially\n\t * selected range to it, to determine the whole range offset.\n\t *\n\t * @param {Integer} currentPageXPos The current horizontal position of the cursor/touch\n\t * @param {Integer} initialStartHandlePageXPos The initial horizontal position of the start handle\n\t *\n\t * @private\n\t */\n\t_calculateRangeOffset(currentPageXPos, initialStartHandlePageXPos) {\n\t\t// Return the current values if there is no difference in the\n\t\t// possitions of the initial press and the current pointer\n\t\tif (this._initialPageXPosition === currentPageXPos) {\n\t\t\treturn [this.startValue, this.endValue];\n\t\t}\n\n\t\tconst min = this._effectiveMin;\n\t\tconst max = this._effectiveMax;\n\t\tconst selectedRange = this.endValue - this.startValue;\n\n\t\t// Computes the new value based on the difference of the current cursor location from the start of the interaction\n\t\tlet startValue = this._calculateStartValueByOffset(currentPageXPos, initialStartHandlePageXPos);\n\n\t\t// When the end handle reaches the max possible value prevent the start handle from moving\n\t\t// And the opposite - if the start handle reaches the beginning of the slider keep the initially selected range.\n\t\tstartValue = this.constructor.clipValue(startValue, min, max - selectedRange);\n\n\t\treturn [startValue, startValue + selectedRange];\n\t}\n\n\t/**\n\t * Computes the new value based on the difference of the current cursor location from the\n\t * start of the interaction.\n\t *\n\t * @param {Integer} currentPageXPos The current horizontal position of the cursor/touch\n\t * @param {Integer} initialStartHandlePageXPos The initial horizontal position of the start handle\n\t *\n\t * @private\n\t */\n\t_calculateStartValueByOffset(currentPageXPos, initialStartHandlePageXPos) {\n\t\tconst min = this._effectiveMin;\n\t\tconst max = this._effectiveMax;\n\t\tconst step = this._effectiveStep;\n\t\tconst dom = this.getBoundingClientRect();\n\n\t\tlet startValue;\n\t\tlet startValuePageX;\n\t\tlet positionOffset;\n\n\t\t/* Depending on the dragging direction:\n\t\t- calculate the new position of the start handle from its old pageX value combined with the movement offset;\n\t\t- calculate the start value based on its new pageX coordinates;\n\t\t- 'stepify' the calculated value based on the specified step property; */\n\t\tif (currentPageXPos > this._initialPageXPosition) {\n\t\t\t// Difference between the new position of the pointer and when the press event initial occured\n\t\t\tpositionOffset = currentPageXPos - this._initialPageXPosition;\n\n\t\t\tstartValuePageX = initialStartHandlePageXPos + positionOffset;\n\t\t\tstartValue = this.constructor.computedValueFromPageX(startValuePageX, min, max, dom, this.directionStart);\n\t\t\tstartValue = this.constructor.getSteppedValue(startValue, step, min);\n\t\t} else {\n\t\t\tpositionOffset = this._initialPageXPosition - currentPageXPos;\n\t\t\tstartValuePageX = initialStartHandlePageXPos - positionOffset;\n\t\t\tstartValue = this.constructor.computedValueFromPageX(startValuePageX, min, max, dom, this.directionStart);\n\t\t\tstartValue = this.constructor.getSteppedValue(startValue, step, min);\n\t\t}\n\n\t\treturn startValue;\n\t}\n\n\t_updateHandlesAndRange(newValue) {\n\t\tconst max = this._effectiveMax;\n\t\tconst min = this._effectiveMin;\n\t\tconst prevStartValue = this.getStoredPropertyState(\"startValue\");\n\t\tconst prevEndValue = this.getStoredPropertyState(\"endValue\");\n\n\t\t// The value according to which we update the UI can be either the startValue\n\t\t// or the endValue property. It is determined in _getClosestHandle()\n\t\t// depending on to which handle is closer the user interaction.\n\t\tif (this._valueAffected === \"startValue\") {\n\t\t\t// When the value changing is the start value:\n\t\t\tthis._selectedRange = (prevEndValue - newValue) / (max - min);\n\t\t\tthis._firstHandlePositionFromStart = ((newValue - min) / (max - min)) * 100;\n\t\t} else if (this._valueAffected === \"endValue\") {\n\t\t\t// Wen the value changing is the end value:\n\t\t\tthis._selectedRange = ((newValue - prevStartValue)) / (max - min);\n\t\t\tthis._secondHandlePositionFromStart = (newValue - min) / (max - min) * 100;\n\t\t} else {\n\t\t\t// When both values are changed - UI sync or moving the whole selected range:\n\t\t\tthis._selectedRange = ((this.endValue - this.startValue)) / (max - min);\n\t\t\tthis._firstHandlePositionFromStart = ((this.startValue - min) / (max - min)) * 100;\n\t\t\tthis._secondHandlePositionFromStart = (this.endValue - min) / (max - min) * 100;\n\t\t}\n\t}\n\n\t/**\n\t * Swaps start and end values and handles (thumbs), if one came accros the other\n\t *\n\t * @private\n\t */\n\t_swapValues() {\n\t\t// If the start value is greater than the endValue swap them and their handles\n\t\tif (this._valueAffected === \"startValue\" && this.startValue > this.endValue) {\n\t\t\tconst oldEndValue = this.endValue;\n\t\t\tthis.endValue = this.startValue;\n\t\t\tthis.startValue = oldEndValue;\n\t\t\treturn;\n\t\t}\n\n\t\t// If the endValue become less than the start value swap them and their handles\n\t\tif (this._valueAffected === \"endValue\" && this.endValue < this.startValue) {\n\t\t\tconst oldStartValue = this.startValue;\n\t\t\tthis.startValue = this.endValue;\n\t\t\tthis.endValue = oldStartValue;\n\t\t}\n\t}\n\n\tget styles() {\n\t\treturn {\n\t\t\tprogress: {\n\t\t\t\t\"transform\": `scaleX(${this._selectedRange})`,\n\t\t\t\t\"transform-origin\": `${this.directionStart} top`,\n\t\t\t\t[this.directionStart]: `${this._firstHandlePositionFromStart}%`,\n\t\t\t},\n\t\t\tstartHandle: {\n\t\t\t\t[this.directionStart]: `${this._firstHandlePositionFromStart}%`,\n\t\t\t},\n\t\t\tendHandle: {\n\t\t\t\t[this.directionStart]: `${this._secondHandlePositionFromStart}%`,\n\t\t\t},\n\t\t\ttickmarks: {\n\t\t\t\t\"background\": `${this._tickmarks}`,\n\t\t\t},\n\t\t\tlabel: {\n\t\t\t\t\"width\": `${this._labelWidth}%`,\n\t\t\t},\n\t\t\tlabelContainer: {\n\t\t\t\t\"width\": `100%`,\n\t\t\t\t[this.directionStart]: `-${this._labelWidth / 2}%`,\n\t\t\t},\n\t\t\ttooltip: {\n\t\t\t\t\"visibility\": `${this._tooltipVisibility}`,\n\t\t\t},\n\t\t};\n\t}\n\n\tstatic async onDefine() {\n\t\tawait fetchI18nBundle(\"@ui5/webcomponents\");\n\t}\n}\n\nRangeSlider.define();\n\nexport default RangeSlider;\n"],"sourceRoot":""}