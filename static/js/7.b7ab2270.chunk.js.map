{"version":3,"sources":["../node_modules/@ui5/webcomponents-base/dist/delegate/NativeResize.js","../node_modules/@ui5/webcomponents-base/dist/delegate/CustomResize.js","../node_modules/@ui5/webcomponents-base/dist/delegate/ResizeHandler.js","../node_modules/@ui5/webcomponents/dist/generated/themes/SliderBase.css.js","../node_modules/@ui5/webcomponents/dist/SliderBase.js"],"names":["NativeResize","resizeObserver","window","ResizeObserver","entries","forEach","entry","observedObjects","get","target","el","Map","ref","callback","observedDOMs","callbacks","length","observe","set","filteredCallbacks","filter","fn","unobserve","delete","CustomResize","initialized","resizeInterval","undefined","resizeListeners","observedObject","existingCallbacks","width","offsetWidth","height","offsetHeight","concat","initListener","size","setInterval","checkListeners","bind","checkSizes","_hasBeenRendered","updateSizes","sizes","newWidth","newHeight","oldHeight","oldWidth","listenerObject","Object","assign","clearInterval","ResizeHandler","Implementation","initialize","attachListener","call","detachListener","isUI5Element","getDomRef","registerThemeProperties","defaultThemeBase","defaultTheme","metadata","properties","min","type","Float","defaultValue","max","step","labelInterval","Integer","showTickmarks","Boolean","showTooltip","disabled","_tooltipVisibility","String","_labelsOverlapping","_hiddenTickmarks","events","change","input","SliderBase","_resizeHandler","_handleResize","_moveHandler","_handleMove","_upHandler","_handleUp","_stateStorage","register","this","deregister","notResized","event","_onmousedown","_spaceBetweenTickmarks","MIN_SPACE_BETWEEN_TICKMARKS","labelItems","shadowRoot","querySelectorAll","some","label","scrollWidth","clientWidth","_effectiveMin","_effectiveMax","domRect","getBoundingClientRect","directionStart","_effectiveStep","newValue","getValueFromInteraction","isPhone","_isUserInteraction","_moveEventType","MOVE_EVENT_MAP","UP_EVENTS","upEventType","addEventListener","valueType","removeEventListener","value","storePropertyState","fireEvent","isPropertyUpdated","_validateStep","values","normalizedValue","clipValue","updateValue","_createLabels","propName","propValue","property","prop","getStoredPropertyState","props","newNumberOfLabels","_oldNumberOfLabels","_labelWidth","_labelValues","stepPrecision","_getDecimalPrecisionOfNumber","i","labelItemNumber","toFixed","push","tickmarksAmountStrCalc","_tickmarksAmount","split","tickmarksAmount","console","warn","Number","isNaN","labelContainer","effectiveDir","maxStr","minStr","stepStr","currentTheme","getTheme","currentColor","TICKMARK_COLOR_MAP","tickmarksGradientBase","tickmarksGradientdPattern","Math","abs","stepSize","boundingClientRect","pageX","getPageXValueFromEvent","computedValueFromPageX","steppedValue","getSteppedValue","stepModuloValue","targetTouches","isInteger","match","litRender","sap_fiori_3","sap_fiori_3_dark","sap_fiori_3_hcw","sap_fiori_3_hcb","sap_belize","sap_belize_hcw","sap_belize_hcb","mousedown","touchstart","UI5Element"],"mappings":"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","file":"static/js/7.b7ab2270.chunk.js","sourcesContent":["class NativeResize {\n\tstatic initialize() {\n\t\tNativeResize.resizeObserver = new window.ResizeObserver(entries => {\n\t\t\t// call attached callbacks\n\t\t\tentries.forEach(entry => {\n\t\t\t\tconst callbacks = NativeResize.observedObjects.get(entry.target);\n\n\t\t\t\tcallbacks.forEach(el => el());\n\t\t\t});\n\t\t});\n\n\t\tNativeResize.observedObjects = new Map();\n\t}\n\n\tstatic attachListener(ref, callback) {\n\t\tconst observedDOMs = NativeResize.observedObjects;\n\t\tconst callbacks = observedDOMs.get(ref) || [];\n\n\t\t// if no callbacks has been added for this ref - start observing it\n\t\tif (!callbacks.length) {\n\t\t\tNativeResize.resizeObserver.observe(ref);\n\t\t}\n\n\t\t// save the callbacks in an array\n\t\tobservedDOMs.set(ref, [...callbacks, callback]);\n\t}\n\n\tstatic detachListener(ref, callback) {\n\t\tconst callbacks = NativeResize.observedObjects.get(ref) || [];\n\t\tconst filteredCallbacks = callbacks.filter(fn => fn !== callback);\n\n\t\tif (!callbacks.length || (callbacks.length === filteredCallbacks.length && callbacks.length !== 0)) {\n\t\t\treturn;\n\t\t}\n\n\t\tNativeResize.observedObjects.set(ref, filteredCallbacks);\n\n\t\tif (!filteredCallbacks.length) {\n\t\t\tNativeResize.resizeObserver.unobserve(ref);\n\t\t\tNativeResize.observedObjects.delete(ref);\n\t\t}\n\t}\n}\n\nexport default NativeResize;\n","const INTERVAL = 300;\n\nclass CustomResize {\n\tstatic initialize() {\n\t\tCustomResize.initialized = false;\n\t\tCustomResize.resizeInterval = undefined;\n\t\tCustomResize.resizeListeners = new Map();\n\t}\n\n\tstatic attachListener(ref, callback) {\n\t\tconst observedObject = CustomResize.resizeListeners.get(ref);\n\t\tconst existingCallbacks = observedObject ? observedObject.callbacks : [];\n\n\t\tCustomResize.resizeListeners.set(ref, {\n\t\t\twidth: ref ? ref.offsetWidth : 0,\n\t\t\theight: ref ? ref.offsetHeight : 0,\n\t\t\tcallbacks: existingCallbacks.concat(callback),\n\t\t});\n\n\t\tCustomResize.initListener();\n\t}\n\n\tstatic initListener() {\n\t\tif (CustomResize.resizeListeners.size > 0 && !CustomResize.initialized) {\n\t\t\tCustomResize.resizeInterval = setInterval(CustomResize.checkListeners.bind(CustomResize), INTERVAL);\n\t\t}\n\t}\n\n\tstatic checkListeners() {\n\t\tCustomResize.resizeListeners.forEach((entry, ref) => {\n\t\t\tconst changed = CustomResize.checkSizes(entry, ref);\n\n\t\t\tif (changed || (entry && !entry._hasBeenRendered)) {\n\t\t\t\tCustomResize.updateSizes(entry, ref.offsetWidth, ref.offsetHeight);\n\t\t\t\tentry.callbacks.forEach(el => el());\n\t\t\t\tentry._hasBeenRendered = true;\n\t\t\t}\n\t\t});\n\t}\n\n\tstatic updateSizes(sizes, newWidth, newHeight) {\n\t\tsizes.width = newWidth;\n\t\tsizes.height = newHeight;\n\t}\n\n\tstatic checkSizes(entry, ref) {\n\t\tconst oldHeight = entry.height;\n\t\tconst oldWidth = entry.width;\n\t\tconst newHeight = ref.offsetHeight;\n\t\tconst newWidth = ref.offsetWidth;\n\n\t\treturn ((oldHeight !== newHeight) || oldWidth !== newWidth);\n\t}\n\n\tstatic detachListener(ref, callback) {\n\t\tconst listenerObject = CustomResize.resizeListeners.get(ref);\n\t\tconst callbacks = listenerObject ? listenerObject.callbacks : [];\n\t\tconst filteredCallbacks = callbacks.filter(fn => fn !== callback);\n\n\t\tif (!listenerObject || (callbacks.length === filteredCallbacks.length && callbacks.length !== 0)) {\n\t\t\treturn;\n\t\t}\n\n\t\tCustomResize.resizeListeners.set(ref, Object.assign(listenerObject, { callbacks: filteredCallbacks }));\n\n\t\tif (!filteredCallbacks.length) {\n\t\t\tlistenerObject.callbacks = null;\n\t\t\tCustomResize.resizeListeners.delete(ref);\n\t\t}\n\n\t\tif (CustomResize.resizeListeners.size === 0) {\n\t\t\tCustomResize.initialized = false;\n\t\t\tclearInterval(CustomResize.resizeInterval);\n\t\t}\n\t}\n}\n\nexport default CustomResize;\n","import NativeResize from \"./NativeResize.js\";\nimport CustomResize from \"./CustomResize.js\";\n\nclass ResizeHandler {\n\tstatic initialize() {\n\t\tResizeHandler.Implementation = window.ResizeObserver ? NativeResize : CustomResize;\n\t\tResizeHandler.Implementation.initialize();\n\t}\n\n\t/**\n\t * @static\n\t * @private\n\t * @param {*} ref Reference to be observed\n\t * @param {*} callback Callback to be executed\n\t * @memberof ResizeHandler\n\t */\n\tstatic attachListener(ref, callback) {\n\t\tResizeHandler.Implementation.attachListener.call(ResizeHandler.Implementation, ref, callback);\n\t}\n\n\t/**\n\t * @static\n\t * @private\n\t * @param {*} ref Reference to be unobserved\n\t * @memberof ResizeHandler\n\t */\n\tstatic detachListener(ref, callback) {\n\t\tResizeHandler.Implementation.detachListener.call(ResizeHandler.Implementation, ref, callback);\n\t}\n\n\n\t/**\n\t * @static\n\t * @public\n\t * @param {*} ref Reference to a UI5 Web Component or DOM Element to be observed\n\t * @param {*} callback Callback to be executed\n\t * @memberof ResizeHandler\n\t */\n\tstatic register(ref, callback) {\n\t\tif (ref.isUI5Element) {\n\t\t\tref = ref.getDomRef();\n\t\t}\n\n\t\tResizeHandler.attachListener(ref, callback);\n\t}\n\n\n\t/**\n\t * @static\n\t * @public\n\t * @param {*} ref Reference to UI5 Web Component or DOM Element to be unobserved\n\t * @memberof ResizeHandler\n\t */\n\tstatic deregister(ref, callback) {\n\t\tif (ref.isUI5Element) {\n\t\t\tref = ref.getDomRef();\n\t\t}\n\n\t\tResizeHandler.detachListener(ref, callback);\n\t}\n}\n\nResizeHandler.initialize();\n\nexport default ResizeHandler;\n","import { registerThemeProperties } from \"@ui5/webcomponents-base/dist/asset-registries/Themes.js\";\n\nimport defaultThemeBase from \"@ui5/webcomponents-theme-base/dist/generated/themes/sap_fiori_3/parameters-bundle.css.js\";\nimport defaultTheme from \"./sap_fiori_3/parameters-bundle.css.js\";\n\nregisterThemeProperties(\"@ui5/webcomponents-theme-base\", \"sap_fiori_3\", defaultThemeBase);\nregisterThemeProperties(\"@ui5/webcomponents\", \"sap_fiori_3\", defaultTheme);\nexport default \":host([disabled]){opacity:var(--_ui5_slider_disabled_opacity);cursor:default;pointer-events:none}:host{box-sizing:border-box;cursor:pointer;vertical-align:top;width:100%;height:3.3125rem}:host(:not([hidden])){display:inline-block}.ui5-slider-root{box-sizing:border-box;height:3.3125rem;padding:1rem 0;touch-action:none;-ms-touch-action:pan-y}.ui5-slider-inner{background-repeat:no-repeat;position:relative;min-width:var(--_ui5_slider_inner_min_width);height:100%}.ui5-slider-progress-container{width:100%;background:var(--_ui5_slider_progress_container_background);border:var(--_ui5_slider_progress_border);border-radius:var(--_ui5_slider_progress_border_radius);height:var(--_ui5_slider_inner_height);position:relative}.ui5-slider-progress{background:var(--_ui5_slider_progress_background);border-radius:var(--_ui5_slider_progress_border_radius);height:var(--_ui5_slider_inner_height);will-change:transform;position:relative}.ui5-slider-tickmarks{color:var(--_ui5_slider_tickmark_color);position:absolute;width:100%;height:1rem;top:var(--_ui5_slider_tickmark_top)}.ui5-slider-handle{background:var(--_ui5_slider_handle_background);border:var(--_ui5_slider_handle_border);border-radius:1rem;margin-left:var(--_ui5_slider_handle_margin_left);top:var(--_ui5_slider_handle_top);position:absolute;outline:none;height:var(--_ui5_slider_handle_height);width:var(--_ui5_slider_handle_width)}.ui5-slider-handle--end,.ui5-slider-handle--start{background:var(--_ui5_range_slider_handle_background)}[dir=rtl] .ui5-slider-handle{margin-right:var(--_ui5_slider_handle_margin_left)}.ui5-slider-handle:active,.ui5-slider-root:active .ui5-slider-handle,.ui5-slider-root:hover .ui5-slider-handle{background:var(--_ui5_slider_handle_hover_background);border-color:var(--_ui5_slider_handle_hover_border)}.ui5-slider-handle--end:active,.ui5-slider-handle--start:active,.ui5-slider-root:active .ui5-slider-handle--end,.ui5-slider-root:active .ui5-slider-handle--start,.ui5-slider-root:hover .ui5-slider-handle--end,.ui5-slider-root:hover .ui5-slider-handle--start{background:var(--_ui5_range_slider_handle_hover_background)}.ui5-slider-tooltip{text-align:center;visibility:hidden;pointer-events:none;line-height:1rem;position:absolute;left:50%;transform:translate(-50%);bottom:var(--_ui5_slider_tooltip_bottom);background:var(--_ui5_slider_tooltip_background);border:1px solid var(--_ui5_slider_tooltip_border_color);border-radius:var(--_ui5_slider_tooltip_border_radius);box-shadow:var(--_ui5_slider_tooltip_box_shadow);font-size:var(--_ui5_slider_tooltip_fontsize);color:var(--_ui5_slider_tooltip_color);height:var(--_ui5_slider_tooltip_height);min-width:var(--_ui5_slider_tooltip_min_width);padding:var(--_ui5_slider_tooltip_padding)}.ui5-slider-tooltip-value{position:relative}.ui5-slider-labels{position:absolute;top:1rem;margin:0;padding:0;white-space:nowrap}.ui5-slider-labels li{position:relative;list-style:none;padding-top:.3125rem;height:1rem;margin:0;text-align:center;display:inline-block;color:var(--_ui5_slider_label_color);font-size:var(--_ui5_slider_label_fontsize)}.ui5-slider-hidden-labels li:not(:first-child):not(:last-child){visibility:hidden}\";","import UI5Element from \"@ui5/webcomponents-base/dist/UI5Element.js\";\nimport litRender from \"@ui5/webcomponents-base/dist/renderer/LitRenderer.js\";\nimport Float from \"@ui5/webcomponents-base/dist/types/Float.js\";\nimport Integer from \"@ui5/webcomponents-base/dist/types/Integer.js\";\nimport ResizeHandler from \"@ui5/webcomponents-base/dist/delegate/ResizeHandler.js\";\nimport { isPhone } from \"@ui5/webcomponents-base/dist/Device.js\";\n\nimport { getTheme } from \"@ui5/webcomponents-base/dist/config/Theme.js\";\n\n// Styles\nimport styles from \"./generated/themes/SliderBase.css.js\";\n\n/**\n * @public\n */\nconst metadata = {\n\tproperties: /** @lends sap.ui.webcomponents.main.SliderBase.prototype */  {\n\t\t/**\n\t\t * Defines the minimum value of the slider\n\t\t *\n\t\t * @type {Float}\n\t\t * @defaultvalue 0\n\t\t * @public\n\t\t */\n\t\tmin: {\n\t\t\ttype: Float,\n\t\t\tdefaultValue: 0,\n\t\t},\n\t\t/**\n\t\t * Defines the maximum value of the slider\n\t\t *\n\t\t * @type {Float}\n\t\t * @defaultvalue 100\n\t\t * @public\n\t\t */\n\t\tmax: {\n\t\t\ttype: Float,\n\t\t\tdefaultValue: 100,\n\t\t},\n\t\t/**\n\t\t * Defines the size of the slider's selection intervals (e.g. min = 0, max = 10, step = 5 would result in possible selection of the values 0, 5, 10).\n\t\t * <br><br>\n\t\t * <b>Note:</b> If set to 0 the slider handle movement is disabled. When negative number or value other than a number, the component fallbacks to its default value.\n\t\t *\n\t\t * @type {Integer}\n\t\t * @defaultvalue 1\n\t\t * @public\n\t\t */\n\t\tstep: {\n\t\t\ttype: Float,\n\t\t\tdefaultValue: 1,\n\t\t},\n\t\t/**\n\t\t * Displays a label with a value on every N-th step.\n\t\t * <br><br>\n\t\t * <b>Note:</b> The step and tickmarks properties must be enabled.\n\t\t * Example - if the step value is set to 2 and the label interval is also specified to 2 - then every second\n\t\t * tickmark will be labelled, which means every 4th value number.\n\t\t *\n\t\t * @type {Integer}\n\t\t * @defaultvalue 0\n\t\t * @public\n\t\t */\n\t\tlabelInterval: {\n\t\t\ttype: Integer,\n\t\t\tdefaultValue: 0,\n\t\t},\n\t\t/**\n\t\t * Enables tick marks visualization for each step.\n\t\t * <br><br>\n\t\t * <b>Note:</b> The step must be a positive number.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @defaultvalue false\n\t\t * @public\n\t\t */\n\t\tshowTickmarks: {\n\t\t\ttype: Boolean,\n\t\t},\n\t\t/**\n\t\t * Enables handle tooltip displaying the current value.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @defaultvalue false\n\t\t * @public\n\t\t */\n\t\tshowTooltip: {\n\t\t\ttype: Boolean,\n\t\t},\n\t\t/**\n\t\t * Defines whether the slider is in disabled state.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @defaultvalue false\n\t\t * @public\n\t\t */\n\t\tdisabled: {\n\t\t\ttype: Boolean,\n\t\t},\n\t\t/**\n\t\t * @private\n\t\t */\n\t\t_tooltipVisibility: {\n\t\t\ttype: String,\n\t\t\tdefaultValue: \"hidden\",\n\t\t},\n\t\t_labelsOverlapping: {\n\t\t\ttype: Boolean,\n\t\t},\n\t\t_hiddenTickmarks: {\n\t\t\ttype: Boolean,\n\t\t},\n\t},\n\tevents: /** @lends sap.ui.webcomponents.main.SliderBase.prototype */ {\n\t\t/**\n\t\t * Fired when the value changes and the user has finished interacting with the slider.\n\t\t *\n\t\t * @event\n\t\t * @public\n\t\t*/\n\t\tchange: {},\n\t\t/**\n\t\t * Fired when the value changes due to user interaction that is not yet finished - during mouse/touch dragging.\n\t\t *\n\t\t * @event\n\t\t * @public\n\t\t*/\n\t\tinput: {},\n\t},\n};\n\n/**\n * @class\n *\n * <h3 class=\"comment-api-title\">Overview</h3>\n *\n *\n * @constructor\n * @author SAP SE\n * @alias sap.ui.webcomponents.main.SliderBase\n * @extends sap.ui.webcomponents.base.UI5Element\n * @tagname ui5-slider\n * @public\n */\nclass SliderBase extends UI5Element {\n\tconstructor() {\n\t\tsuper();\n\t\tthis._resizeHandler = this._handleResize.bind(this);\n\t\tthis._moveHandler = this._handleMove.bind(this);\n\t\tthis._upHandler = this._handleUp.bind(this);\n\n\t\tthis._stateStorage = {\n\t\t\tstep: null,\n\t\t\tmin: null,\n\t\t\tmax: null,\n\t\t\tlabelInterval: null,\n\t\t};\n\t}\n\n\tstatic get metadata() {\n\t\treturn metadata;\n\t}\n\n\tstatic get render() {\n\t\treturn litRender;\n\t}\n\n\tstatic get styles() {\n\t\treturn styles;\n\t}\n\n\tstatic get TICKMARK_COLOR_MAP() {\n\t\treturn {\n\t\t\tsap_fiori_3: \"#89919a\",\n\t\t\tsap_fiori_3_dark: \"#89919a\",\n\t\t\tsap_fiori_3_hcw: \"#000000\",\n\t\t\tsap_fiori_3_hcb: \"#ffffff\",\n\t\t\tsap_belize: \"#bfbfbf\",\n\t\t\tsap_belize_hcw: \"#000000\",\n\t\t\tsap_belize_hcb: \"#ffffff\",\n\t\t};\n\t}\n\n\tstatic get UP_EVENTS() {\n\t\treturn [\"mouseup\", \"touchend\"];\n\t}\n\n\tstatic get MOVE_EVENT_MAP() {\n\t\treturn {\n\t\t\tmousedown: \"mousemove\",\n\t\t\ttouchstart: \"touchmove\",\n\t\t};\n\t}\n\n\tstatic get MIN_SPACE_BETWEEN_TICKMARKS() {\n\t\treturn 8;\n\t}\n\n\tget classes() {\n\t\treturn {\n\t\t\tlabelContainer: {\n\t\t\t\t\"ui5-slider-hidden-labels\": this._labelsOverlapping,\n\t\t\t},\n\t\t};\n\t}\n\n\tonEnterDOM() {\n\t\tResizeHandler.register(this, this._resizeHandler);\n\t}\n\n\tonExitDOM() {\n\t\tResizeHandler.deregister(this, this._handleResize);\n\t}\n\n\tonAfterRendering() {\n\t\t// Only call if the resize is triggered by a state changes other than\n\t\t// the ones that occured on the previous resize and those caused by user interaction.\n\t\tif (this.notResized) {\n\t\t\tthis._resizeHandler();\n\t\t}\n\t}\n\n\t_ontouchstart(event) {\n\t\tthis._onmousedown(event);\n\t}\n\n\t/** Shows the tooltip(s) if the <code>showTooltip</code> property is set to true\n\t *\n\t * @private\n\t */\n\t_onmouseover(event) {\n\t\tif (this.showTooltip) {\n\t\t\tthis._tooltipVisibility = \"visible\";\n\t\t}\n\t}\n\n\t/**\n\t * Hides the tooltip(s) if the <code>showTooltip</code> property is set to true\n\t *\n\t * @private\n\t */\n\t_onmouseout(event) {\n\t\tif (this.showTooltip) {\n\t\t\tthis._tooltipVisibility = \"hidden\";\n\t\t}\n\t}\n\n\t/**\n\t * Handle the responsiveness of the Slider's UI elements when resizing\n\t *\n\t * @private\n\t */\n\t_handleResize() {\n\t\tif (!this.showTickmarks) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Mark resizing to avoid unneccessary calls to that function after rendering\n\t\tthis.notResized = false;\n\n\t\t// Convert the string represented calculation expression to a normal one\n\t\t// Check the distance  in pixels exist between every tickmark\n\t\tconst spaceBetweenTickmarks = this._spaceBetweenTickmarks();\n\n\t\t// If the pixels between the tickmarks are less than 8 only the first and the last one should be visible\n\t\t// In such case the labels must correspond to the tickmarks, only the first and the last one should exist.\n\t\tif (spaceBetweenTickmarks < SliderBase.MIN_SPACE_BETWEEN_TICKMARKS) {\n\t\t\tthis._hiddenTickmarks = true;\n\t\t\tthis._labelsOverlapping = true;\n\t\t} else {\n\t\t\tthis._hiddenTickmarks = false;\n\t\t}\n\n\t\tif (this.labelInterval <= 0 || this._hiddenTickmarks) {\n\t\t\treturn;\n\t\t}\n\n\n\t\t// Check if there are any overlapping labels.\n\t\t// If so - only the first and the last one should be visible\n\t\tconst labelItems = this.shadowRoot.querySelectorAll(\".ui5-slider-labels li\");\n\t\tthis._labelsOverlapping = [...labelItems].some(label => label.scrollWidth > label.clientWidth);\n\t}\n\n\t/**\n\t * Called when the user starts interacting with the slider.\n\t * After a down event on the slider root, listen for move events on window, so the slider value\n\t * is updated even if the user drags the pointer outside the slider root.\n\t *\n\t * @protected\n\t */\n\thandleDownBase(event) {\n\t\tconst min = this._effectiveMin;\n\t\tconst max = this._effectiveMax;\n\t\tconst domRect = this.getBoundingClientRect();\n\t\tconst directionStart = this.directionStart;\n\t\tconst step = this._effectiveStep;\n\t\tconst newValue = SliderBase.getValueFromInteraction(event, step, min, max, domRect, directionStart);\n\n\t\tif (isPhone() && this.showTooltip) {\n\t\t\tthis._tooltipVisibility = \"visible\";\n\t\t}\n\n\t\t// Mark start of a user interaction\n\t\tthis._isUserInteraction = true;\n\t\t// Only allow one type of move event to be listened to (the first one registered after the down event)\n\t\tthis._moveEventType = !this._moveEventType ? SliderBase.MOVE_EVENT_MAP[event.type] : this._moveEventType;\n\n\t\tSliderBase.UP_EVENTS.forEach(upEventType => window.addEventListener(upEventType, this._upHandler));\n\t\twindow.addEventListener(this._moveEventType, this._moveHandler);\n\n\t\treturn newValue;\n\t}\n\n\t/**\n\t * Called when the user finish interacting with the slider\n\t * Fires an <code>change</code> event indicating a final value change, after user interaction is finished.\n\t *\n\t * @protected\n\t */\n\thandleUpBase(valueType) {\n\t\tif (isPhone() && this.showTooltip) {\n\t\t\tthis._tooltipVisibility = \"hidden\";\n\t\t}\n\n\t\tSliderBase.UP_EVENTS.forEach(upEventType => window.removeEventListener(upEventType, this._upHandler));\n\t\twindow.removeEventListener(this._moveEventType, this._moveHandler);\n\n\t\tthis._moveEventType = null;\n\t\tthis._isUserInteraction = false;\n\t}\n\n\t/**\n\t * Updates value property of the component that has been changed due to a user action.\n\t * Fires an <code>input</code> event indicating a value change via interaction that is not yet finished.\n\t *\n\t * @protected\n\t */\n\tupdateValue(valueType, value) {\n\t\tthis[valueType] = value;\n\t\tthis.storePropertyState(valueType);\n\t\tif (this._isUserInteraction) {\n\t\t\tthis.fireEvent(\"input\");\n\t\t}\n\t}\n\n\t/**\n\t * Locks the given value between min and max boundaries based on slider properties\n\t *\n\t * @protected\n\t */\n\tstatic clipValue(value, min, max) {\n\t\tvalue = Math.min(Math.max(value, min), max);\n\t\treturn value;\n\t}\n\n\t/**\n\t * Sets the slider value from an event\n\t *\n\t * @protected\n\t */\n\tstatic getValueFromInteraction(event, stepSize, min, max, boundingClientRect, directionStart) {\n\t\tconst pageX = this.getPageXValueFromEvent(event);\n\t\tconst value = this.computedValueFromPageX(pageX, min, max, boundingClientRect, directionStart);\n\t\tconst steppedValue = this.getSteppedValue(value, stepSize, min);\n\n\t\treturn this.clipValue(steppedValue, min, max);\n\t}\n\n\t/**\n\t * \"Stepify\" the raw value - calculate the new value depending on the specified step property\n\t *\n\t * @protected\n\t */\n\tstatic getSteppedValue(value, stepSize, min) {\n\t\tconst stepModuloValue = Math.abs((value - min) % stepSize);\n\n\t\tif (stepSize === 0 || stepModuloValue === 0) {\n\t\t\treturn value;\n\t\t}\n\n\t\t// Clip (snap) the new value to the nearest step\n\t\tvalue = (stepModuloValue * 2 >= stepSize) ? (value + stepSize) - stepModuloValue : value - stepModuloValue;\n\n\t\t// If the step value is not a round number get its precision\n\t\tconst stepPrecision = SliderBase._getDecimalPrecisionOfNumber(stepSize);\n\t\treturn value.toFixed(stepPrecision);\n\t}\n\n\t/**\n\t * Gets pageX value from event on user interaction with the Slider\n\t *\n\t * @protected\n\t */\n\tstatic getPageXValueFromEvent(event) {\n\t\tif (event.targetTouches && event.targetTouches.length > 0) {\n\t\t\treturn event.targetTouches[0].pageX;\n\t\t}\n\n\t\treturn event.pageX;\n\t}\n\n\t/**\n\t * Computes the new value (in %) from the pageX position of the cursor.\n\t * Returns the value rounded to a precision of at most 2 digits after decimal point.\n\t *\n\t * @protected\n\t */\n\tstatic computedValueFromPageX(pageX, min, max, boundingClientRect, directionStart) {\n\t\t// Determine pageX position relative to the Slider DOM\n\t\tconst xRelativePosition = directionStart === \"left\" ? pageX - boundingClientRect[directionStart] : boundingClientRect[directionStart] - pageX;\n\t\t// Calculate the percentage complete (the \"progress\")\n\t\tconst percentageComplete = xRelativePosition / boundingClientRect.width;\n\t\t// Fit (map) the complete percentage between the min/max value range\n\t\treturn min + percentageComplete * (max - min);\n\t}\n\n\t/**\n\t * Calculates the precision (decimal places) of a number, returns 0 if integer\n\t * Handles scientific notation cases.\n\t * @private\n\t */\n\tstatic _getDecimalPrecisionOfNumber(value) {\n\t\tif (Number.isInteger(value)) {\n\t\t\treturn 0;\n\t\t}\n\t\tconst match = (String(value)).match(/(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/);\n\t\treturn Math.max(0, (match[1] ? match[1].length : 0) - (match[2] ? Number(match[2]) : 0));\n\t}\n\n\t/**\n\t * Normalize current properties, update the previously stored state.\n\t *\n\t * @protected\n\t */\n\tsyncUIAndState(...values) {\n\t\t// Validate step and update the stored state for the step property.\n\t\tif (this.isPropertyUpdated(\"step\")) {\n\t\t\tthis._validateStep(this.step);\n\t\t\tthis.storePropertyState(\"step\");\n\t\t}\n\n\t\t// Recalculate the tickmarks and labels and update the stored state.\n\t\tif (this.isPropertyUpdated(\"min\", \"max\", ...values)) {\n\t\t\tthis.storePropertyState(\"min\", \"max\");\n\n\t\t\t// Here the value props are changed programatically (not by user interaction)\n\t\t\t// and it won't be \"stepified\" (rounded to the nearest step). 'Clip' them within\n\t\t\t// min and max bounderies and update the previous state reference.\n\t\t\tvalues.forEach(valueType => {\n\t\t\t\tconst normalizedValue = SliderBase.clipValue(this[valueType], this._effectiveMin, this._effectiveMax);\n\t\t\t\tthis.updateValue(valueType, normalizedValue);\n\t\t\t\tthis.storePropertyState(valueType);\n\t\t\t});\n\t\t}\n\n\t\t// Labels must be updated if any of the min/max/step/labelInterval props are changed\n\t\tif (this.labelInterval && this.showTickmarks) {\n\t\t\tthis._createLabels();\n\t\t}\n\n\t\t// Update the stored state for the labelInterval, if changed\n\t\tif (this.isPropertyUpdated(\"labelInterval\")) {\n\t\t\tthis.storePropertyState(\"labelInterval\");\n\t\t}\n\t}\n\n\t/**\n\t * In order to always keep the visual UI representation and the internal\n\t * state in sync, the component has a 'state storage' that is updated when the\n\t * current state is changed due to a user action.\n\t *\n\t * Check if the previously saved state is outdated. That would mean\n\t * a property has been changed programatically because the previous state\n\t * is always updated in the interaction handlers.\n\t *\n\t * Will return true if any of the properties is not equal to its previously\n\t * stored value.\n\t *\n\t * @protected\n\t */\n\tisCurrentStateOutdated() {\n\t\treturn Object.entries(this._stateStorage).some(([propName, propValue]) => this[propName] !== propValue);\n\t}\n\n\t/**\n\t * Returns the last stored value of a property\n\t *\n\t * @protected\n\t */\n\tgetStoredPropertyState(property) {\n\t\treturn this._stateStorage[property];\n\t}\n\n\t/**\n\t * Check if one or more properties have been updated compared to their last\n\t * saved values in the state storage.\n\t *\n\t * @protected\n\t */\n\tisPropertyUpdated(...properties) {\n\t\treturn properties.some(prop => this.getStoredPropertyState(prop) !== this[prop]);\n\t}\n\n\t/**\n\t * Updates the previously saved in the _stateStorage values of one or more properties.\n\t *\n\t * @protected\n\t */\n\tstorePropertyState(...props) {\n\t\tprops.forEach(property => {\n\t\t\tthis._stateStorage[property] = this[property];\n\t\t});\n\t}\n\n\t/**\n\t * Returns the start side of a direction - left for LTR, right for RTL\n\t */\n\tget directionStart() {\n\t\treturn this.effectiveDir === \"rtl\" ? \"right\" : \"left\";\n\t}\n\n\t/**\n\t * Calculates and draws the tickmarks with a CSS gradient style\n\t *\n\t * @private\n\t */\n\tget _tickmarks() {\n\t\tif (!this.showTickmarks || !this._effectiveStep) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._hiddenTickmarks) {\n\t\t\treturn `linear-gradient(to right, currentColor 1px, transparent 0) 0 center / calc(100% - 1px) 100% repeat-x`;\n\t\t}\n\n\t\t// Convert number values to strings to let the CSS do calculations better\n\t\t// rounding/subpixel behavior\" and the most precise tickmarks distribution\n\t\tconst maxStr = String(this._effectiveMax);\n\t\tconst minStr = String(this._effectiveMin);\n\t\tconst stepStr = String(this._effectiveStep);\n\t\tconst tickmarkWidth = \"1px\";\n\n\t\t// There is a CSS bug with the 'currentcolor' value of a CSS gradient that does not\n\t\t// respect the variable for more than one theme. It has to be set here for now.\n\t\tconst currentTheme = getTheme();\n\t\tconst currentColor = SliderBase.TICKMARK_COLOR_MAP[currentTheme];\n\n\t\tthis._tickmarksAmount = `${maxStr - minStr} / ${stepStr}`;\n\t\tthis._hiddenTickmarks = false;\n\n\t\t// Transparent CSS gradient background\n\t\tconst tickmarksGradientBase = `linear-gradient(to right, ${currentColor} ${tickmarkWidth}, transparent 0) `;\n\n\t\t// Draw the tickmarks as a patern over the gradient background\n\t\tconst tickmarksGradientdPattern = `0 center / calc((100% - ${tickmarkWidth}) / (${this._tickmarksAmount})) 100% repeat-x`;\n\n\t\t// Combine to get the complete CSS background gradient property value\n\t\treturn `${tickmarksGradientBase + tickmarksGradientdPattern}`;\n\t}\n\n\t/**\n\t * Calculates the labels amout, width and text and creates them\n\t *\n\t * @private\n\t */\n\t_createLabels() {\n\t\tif (!this.labelInterval || !this.showTickmarks) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst labelInterval = this.labelInterval;\n\t\tconst step = this._effectiveStep;\n\t\tconst newNumberOfLabels = (this._effectiveMax - this._effectiveMin) / (step * labelInterval);\n\n\t\t// If the required labels are already rendered\n\t\tif (newNumberOfLabels === this._oldNumberOfLabels) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._oldNumberOfLabels = newNumberOfLabels;\n\t\tthis._labelWidth = 100 / newNumberOfLabels;\n\t\tthis._labelValues = [];\n\n\t\t// If the step value is not a round number get its precision\n\t\tconst stepPrecision = SliderBase._getDecimalPrecisionOfNumber(step);\n\n\t\t// numberOfLabels below can be float so that the \"distance betweenlabels labels\"\n\t\t// calculation to be precize (exactly the same as the distance between the tickmarks).\n\t\t// That's ok as the loop stop condition is set to an integer, so it will practically\n\t\t// \"floor\" the number of labels anyway.\n\t\tfor (let i = 0; i <= newNumberOfLabels; i++) {\n\t\t\t// Format the label numbers with the same decimal precision as the value of the step property\n\t\t\tconst labelItemNumber = ((i * step * labelInterval) + this._effectiveMin).toFixed(stepPrecision);\n\t\t\tthis._labelValues.push(labelItemNumber);\n\t\t}\n\t}\n\n\tget _labels() {\n\t\treturn this._labelValues || [];\n\t}\n\n\t/**\n\t * Calculates space between tickmarks\n\t *\n\t * @private\n\t */\n\t_spaceBetweenTickmarks() {\n\t\tconst tickmarksAmountStrCalc = this._tickmarksAmount.split(\"/\");\n\t\tconst tickmarksAmount = tickmarksAmountStrCalc[0] / tickmarksAmountStrCalc[1];\n\n\t\treturn this.getBoundingClientRect().width / tickmarksAmount;\n\t}\n\n\t/**\n\t * Notify in case of a invalid step value type\n\t *\n\t * @private\n\t */\n\t_validateStep(step) {\n\t\tif (step === 0) {\n\t\t\tconsole.warn(\"The 'step' property must be a positive float number\"); // eslint-disable-line\n\t\t}\n\n\t\tif (step < 0) {\n\t\t\tconsole.warn(\"The 'step' property must be a positive float number. The provided negative number has been converted to its positve equivalent\"); // eslint-disable-line\n\t\t}\n\n\t\tif (typeof step !== \"number\" || Number.isNaN(step)) {\n\t\t\tconsole.warn(\"The 'step' property must be a positive float number. It has been set to its default value of 1\"); // eslint-disable-line\n\t\t}\n\t}\n\n\t/**\n\t * Normalizes a new <code>step</code> property value.\n\t * If tickmarks are enabled recreates them according to it.\n\t *\n\t * @private\n\t */\n\tget _effectiveStep() {\n\t\tlet step = this.step;\n\n\t\tif (step < 0) {\n\t\t\tstep = Math.abs(step);\n\t\t}\n\n\t\tif (typeof step !== \"number\" || Number.isNaN(step)) {\n\t\t\tstep = 1;\n\t\t}\n\n\t\treturn step;\n\t}\n\n\tget _effectiveMin() {\n\t\treturn Math.min(this.min, this.max);\n\t}\n\n\tget _effectiveMax() {\n\t\treturn Math.max(this.min, this.max);\n\t}\n}\n\nexport default SliderBase;\n"],"sourceRoot":""}